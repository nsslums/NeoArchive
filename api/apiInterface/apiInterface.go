// Package apiInterface provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
package apiInterface

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// AnimeEpisode defines model for AnimeEpisode.
type AnimeEpisode struct {
	Id       int     `json:"id"`
	Number   *string `json:"number,omitempty"`
	SeasonId int     `json:"season_id"`
	Subtitle *string `json:"subtitle,omitempty"`
	VideoId  int     `json:"video_id"`
}

// AnimeSeason defines model for AnimeSeason.
type AnimeSeason struct {
	// Cast 出演者
	Cast *string `json:"cast,omitempty"`

	// Cours クール(秋アニメ,冬アニメ,春アニメ,夏アニメ)
	Cours *string `json:"cours,omitempty"`
	Id    int     `json:"id"`

	// Production 制作会社
	Production *string `json:"production,omitempty"`
	SeriesId   int     `json:"series_id"`

	// Synopsis あらすじ
	Synopsis *string `json:"synopsis,omitempty"`
	Title    string  `json:"title"`
}

// DefaultErrorResponse defines model for DefaultErrorResponse.
type DefaultErrorResponse struct {
	Message *string `json:"message,omitempty"`
}

// Series defines model for Series.
type Series struct {
	Id    int    `json:"id"`
	Tags  *[]Tag `json:"tags,omitempty"`
	Title string `json:"title"`
}

// Tag defines model for Tag.
type Tag struct {
	Id   int    `json:"id"`
	Name string `json:"name"`
}

// Video defines model for Video.
type Video struct {
	BroadcastTime *int `json:"broadcast_time,omitempty"`
	Id            int  `json:"id"`
	PlaybackTime  *int `json:"playback_time,omitempty"`
}

// VideoLog defines model for VideoLog.
type VideoLog struct {
	Id           int `json:"id"`
	PlaybackTime int `json:"playback_time"`
	UserId       int `json:"user_id"`
	VideoId      int `json:"video_id"`
}

// GetSeriesListParams defines parameters for GetSeriesList.
type GetSeriesListParams struct {
	// Q Search keyword
	Q *string `form:"q,omitempty" json:"q,omitempty"`
}

// CreateAnimeEpisodeJSONRequestBody defines body for CreateAnimeEpisode for application/json ContentType.
type CreateAnimeEpisodeJSONRequestBody = AnimeEpisode

// UpdateAnimeEpisodeJSONRequestBody defines body for UpdateAnimeEpisode for application/json ContentType.
type UpdateAnimeEpisodeJSONRequestBody = AnimeEpisode

// CreateAnimeSeasonJSONRequestBody defines body for CreateAnimeSeason for application/json ContentType.
type CreateAnimeSeasonJSONRequestBody = AnimeSeason

// UpdateAnimeSeasonJSONRequestBody defines body for UpdateAnimeSeason for application/json ContentType.
type UpdateAnimeSeasonJSONRequestBody = AnimeSeason

// CreateSeriesJSONRequestBody defines body for CreateSeries for application/json ContentType.
type CreateSeriesJSONRequestBody = Series

// UpdateSeriesJSONRequestBody defines body for UpdateSeries for application/json ContentType.
type UpdateSeriesJSONRequestBody = Series

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody = Tag

// UpdateTagJSONRequestBody defines body for UpdateTag for application/json ContentType.
type UpdateTagJSONRequestBody = Tag

// CreateVideoJSONRequestBody defines body for CreateVideo for application/json ContentType.
type CreateVideoJSONRequestBody = Video

// UpdateVideoJSONRequestBody defines body for UpdateVideo for application/json ContentType.
type UpdateVideoJSONRequestBody = Video

// CreateVideoLogJSONRequestBody defines body for CreateVideoLog for application/json ContentType.
type CreateVideoLogJSONRequestBody = VideoLog

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateAnimeEpisodeWithBody request with any body
	CreateAnimeEpisodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAnimeEpisode(ctx context.Context, body CreateAnimeEpisodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAnimeEpisodeWithBody request with any body
	UpdateAnimeEpisodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAnimeEpisode(ctx context.Context, body UpdateAnimeEpisodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAnimeEpisode request
	DeleteAnimeEpisode(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeEpisodeList request
	GetAnimeEpisodeList(ctx context.Context, seasonId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAnimeSeasonWithBody request with any body
	CreateAnimeSeasonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAnimeSeason(ctx context.Context, body CreateAnimeSeasonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAnimeSeasonWithBody request with any body
	UpdateAnimeSeasonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAnimeSeason(ctx context.Context, body UpdateAnimeSeasonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAnimeSeason request
	DeleteAnimeSeason(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeSeasonList request
	GetAnimeSeasonList(ctx context.Context, seriesId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSeriesWithBody request with any body
	CreateSeriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSeries(ctx context.Context, body CreateSeriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSeriesWithBody request with any body
	UpdateSeriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSeries(ctx context.Context, body UpdateSeriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSeries request
	DeleteSeries(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeriesList request
	GetSeriesList(ctx context.Context, params *GetSeriesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTagWithBody request with any body
	CreateTagWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTag(ctx context.Context, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTagWithBody request with any body
	UpdateTagWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTag(ctx context.Context, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTag request
	DeleteTag(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTagList request
	GetTagList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVideoWithBody request with any body
	CreateVideoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVideo(ctx context.Context, body CreateVideoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVideoWithBody request with any body
	UpdateVideoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVideo(ctx context.Context, body UpdateVideoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVideo request
	DeleteVideo(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVideo request
	GetVideo(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVideoLogWithBody request with any body
	CreateVideoLogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVideoLog(ctx context.Context, body CreateVideoLogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVideoLog request
	GetVideoLog(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateAnimeEpisodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAnimeEpisodeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAnimeEpisode(ctx context.Context, body CreateAnimeEpisodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAnimeEpisodeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAnimeEpisodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAnimeEpisodeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAnimeEpisode(ctx context.Context, body UpdateAnimeEpisodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAnimeEpisodeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAnimeEpisode(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAnimeEpisodeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeEpisodeList(ctx context.Context, seasonId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeEpisodeListRequest(c.Server, seasonId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAnimeSeasonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAnimeSeasonRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAnimeSeason(ctx context.Context, body CreateAnimeSeasonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAnimeSeasonRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAnimeSeasonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAnimeSeasonRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAnimeSeason(ctx context.Context, body UpdateAnimeSeasonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAnimeSeasonRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAnimeSeason(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAnimeSeasonRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeSeasonList(ctx context.Context, seriesId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeSeasonListRequest(c.Server, seriesId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSeriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSeriesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSeries(ctx context.Context, body CreateSeriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSeriesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSeriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSeriesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSeries(ctx context.Context, body UpdateSeriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSeriesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSeries(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSeriesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesList(ctx context.Context, params *GetSeriesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTagWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTag(ctx context.Context, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTagWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTagRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTag(ctx context.Context, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTagRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTag(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTagList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVideoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVideoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVideo(ctx context.Context, body CreateVideoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVideoRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVideoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVideoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVideo(ctx context.Context, body UpdateVideoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVideoRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVideo(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVideoRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVideo(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVideoRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVideoLogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVideoLogRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVideoLog(ctx context.Context, body CreateVideoLogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVideoLogRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVideoLog(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVideoLogRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateAnimeEpisodeRequest calls the generic CreateAnimeEpisode builder with application/json body
func NewCreateAnimeEpisodeRequest(server string, body CreateAnimeEpisodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAnimeEpisodeRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAnimeEpisodeRequestWithBody generates requests for CreateAnimeEpisode with any type of body
func NewCreateAnimeEpisodeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/episode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateAnimeEpisodeRequest calls the generic UpdateAnimeEpisode builder with application/json body
func NewUpdateAnimeEpisodeRequest(server string, body UpdateAnimeEpisodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAnimeEpisodeRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateAnimeEpisodeRequestWithBody generates requests for UpdateAnimeEpisode with any type of body
func NewUpdateAnimeEpisodeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/episode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAnimeEpisodeRequest generates requests for DeleteAnimeEpisode
func NewDeleteAnimeEpisodeRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/episode/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeEpisodeListRequest generates requests for GetAnimeEpisodeList
func NewGetAnimeEpisodeListRequest(server string, seasonId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "season_id", runtime.ParamLocationPath, seasonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/episode_list/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAnimeSeasonRequest calls the generic CreateAnimeSeason builder with application/json body
func NewCreateAnimeSeasonRequest(server string, body CreateAnimeSeasonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAnimeSeasonRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAnimeSeasonRequestWithBody generates requests for CreateAnimeSeason with any type of body
func NewCreateAnimeSeasonRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/season")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateAnimeSeasonRequest calls the generic UpdateAnimeSeason builder with application/json body
func NewUpdateAnimeSeasonRequest(server string, body UpdateAnimeSeasonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAnimeSeasonRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateAnimeSeasonRequestWithBody generates requests for UpdateAnimeSeason with any type of body
func NewUpdateAnimeSeasonRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/season")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAnimeSeasonRequest generates requests for DeleteAnimeSeason
func NewDeleteAnimeSeasonRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/season/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeSeasonListRequest generates requests for GetAnimeSeasonList
func NewGetAnimeSeasonListRequest(server string, seriesId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/season_list/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSeriesRequest calls the generic CreateSeries builder with application/json body
func NewCreateSeriesRequest(server string, body CreateSeriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSeriesRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSeriesRequestWithBody generates requests for CreateSeries with any type of body
func NewCreateSeriesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/series")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateSeriesRequest calls the generic UpdateSeries builder with application/json body
func NewUpdateSeriesRequest(server string, body UpdateSeriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSeriesRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateSeriesRequestWithBody generates requests for UpdateSeries with any type of body
func NewUpdateSeriesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/series")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSeriesRequest generates requests for DeleteSeries
func NewDeleteSeriesRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/series/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeriesListRequest generates requests for GetSeriesList
func NewGetSeriesListRequest(server string, params *GetSeriesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/series_list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTagRequest calls the generic CreateTag builder with application/json body
func NewCreateTagRequest(server string, body CreateTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTagRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTagRequestWithBody generates requests for CreateTag with any type of body
func NewCreateTagRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateTagRequest calls the generic UpdateTag builder with application/json body
func NewUpdateTagRequest(server string, body UpdateTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTagRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateTagRequestWithBody generates requests for UpdateTag with any type of body
func NewUpdateTagRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTagRequest generates requests for DeleteTag
func NewDeleteTagRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tag/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTagListRequest generates requests for GetTagList
func NewGetTagListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tag_list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVideoRequest calls the generic CreateVideo builder with application/json body
func NewCreateVideoRequest(server string, body CreateVideoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVideoRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateVideoRequestWithBody generates requests for CreateVideo with any type of body
func NewCreateVideoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/video")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateVideoRequest calls the generic UpdateVideo builder with application/json body
func NewUpdateVideoRequest(server string, body UpdateVideoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVideoRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateVideoRequestWithBody generates requests for UpdateVideo with any type of body
func NewUpdateVideoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/video")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVideoRequest generates requests for DeleteVideo
func NewDeleteVideoRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/video/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVideoRequest generates requests for GetVideo
func NewGetVideoRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/video/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVideoLogRequest calls the generic CreateVideoLog builder with application/json body
func NewCreateVideoLogRequest(server string, body CreateVideoLogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVideoLogRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateVideoLogRequestWithBody generates requests for CreateVideoLog with any type of body
func NewCreateVideoLogRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/video_log")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVideoLogRequest generates requests for GetVideoLog
func NewGetVideoLogRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/video_log/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateAnimeEpisodeWithBodyWithResponse request with any body
	CreateAnimeEpisodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAnimeEpisodeResponse, error)

	CreateAnimeEpisodeWithResponse(ctx context.Context, body CreateAnimeEpisodeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAnimeEpisodeResponse, error)

	// UpdateAnimeEpisodeWithBodyWithResponse request with any body
	UpdateAnimeEpisodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAnimeEpisodeResponse, error)

	UpdateAnimeEpisodeWithResponse(ctx context.Context, body UpdateAnimeEpisodeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAnimeEpisodeResponse, error)

	// DeleteAnimeEpisodeWithResponse request
	DeleteAnimeEpisodeWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteAnimeEpisodeResponse, error)

	// GetAnimeEpisodeListWithResponse request
	GetAnimeEpisodeListWithResponse(ctx context.Context, seasonId int, reqEditors ...RequestEditorFn) (*GetAnimeEpisodeListResponse, error)

	// CreateAnimeSeasonWithBodyWithResponse request with any body
	CreateAnimeSeasonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAnimeSeasonResponse, error)

	CreateAnimeSeasonWithResponse(ctx context.Context, body CreateAnimeSeasonJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAnimeSeasonResponse, error)

	// UpdateAnimeSeasonWithBodyWithResponse request with any body
	UpdateAnimeSeasonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAnimeSeasonResponse, error)

	UpdateAnimeSeasonWithResponse(ctx context.Context, body UpdateAnimeSeasonJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAnimeSeasonResponse, error)

	// DeleteAnimeSeasonWithResponse request
	DeleteAnimeSeasonWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteAnimeSeasonResponse, error)

	// GetAnimeSeasonListWithResponse request
	GetAnimeSeasonListWithResponse(ctx context.Context, seriesId int, reqEditors ...RequestEditorFn) (*GetAnimeSeasonListResponse, error)

	// CreateSeriesWithBodyWithResponse request with any body
	CreateSeriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSeriesResponse, error)

	CreateSeriesWithResponse(ctx context.Context, body CreateSeriesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSeriesResponse, error)

	// UpdateSeriesWithBodyWithResponse request with any body
	UpdateSeriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSeriesResponse, error)

	UpdateSeriesWithResponse(ctx context.Context, body UpdateSeriesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSeriesResponse, error)

	// DeleteSeriesWithResponse request
	DeleteSeriesWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteSeriesResponse, error)

	// GetSeriesListWithResponse request
	GetSeriesListWithResponse(ctx context.Context, params *GetSeriesListParams, reqEditors ...RequestEditorFn) (*GetSeriesListResponse, error)

	// CreateTagWithBodyWithResponse request with any body
	CreateTagWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagResponse, error)

	CreateTagWithResponse(ctx context.Context, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagResponse, error)

	// UpdateTagWithBodyWithResponse request with any body
	UpdateTagWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error)

	UpdateTagWithResponse(ctx context.Context, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error)

	// DeleteTagWithResponse request
	DeleteTagWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error)

	// GetTagListWithResponse request
	GetTagListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTagListResponse, error)

	// CreateVideoWithBodyWithResponse request with any body
	CreateVideoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVideoResponse, error)

	CreateVideoWithResponse(ctx context.Context, body CreateVideoJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVideoResponse, error)

	// UpdateVideoWithBodyWithResponse request with any body
	UpdateVideoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVideoResponse, error)

	UpdateVideoWithResponse(ctx context.Context, body UpdateVideoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVideoResponse, error)

	// DeleteVideoWithResponse request
	DeleteVideoWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteVideoResponse, error)

	// GetVideoWithResponse request
	GetVideoWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetVideoResponse, error)

	// CreateVideoLogWithBodyWithResponse request with any body
	CreateVideoLogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVideoLogResponse, error)

	CreateVideoLogWithResponse(ctx context.Context, body CreateVideoLogJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVideoLogResponse, error)

	// GetVideoLogWithResponse request
	GetVideoLogWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetVideoLogResponse, error)
}

type CreateAnimeEpisodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AnimeEpisode
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateAnimeEpisodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAnimeEpisodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAnimeEpisodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnimeEpisode
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateAnimeEpisodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAnimeEpisodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAnimeEpisodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteAnimeEpisodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAnimeEpisodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeEpisodeListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AnimeEpisode
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAnimeEpisodeListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeEpisodeListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAnimeSeasonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AnimeSeason
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateAnimeSeasonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAnimeSeasonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAnimeSeasonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnimeSeason
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateAnimeSeasonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAnimeSeasonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAnimeSeasonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteAnimeSeasonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAnimeSeasonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeSeasonListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AnimeSeason
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAnimeSeasonListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeSeasonListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSeriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Series
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateSeriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSeriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSeriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Series
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateSeriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSeriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSeriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteSeriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSeriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Series
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSeriesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Tag
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tag
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Tag
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTagListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVideoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Video
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateVideoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVideoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVideoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Video
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateVideoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVideoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVideoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteVideoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVideoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVideoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Video
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVideoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVideoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVideoLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VideoLog
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateVideoLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVideoLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVideoLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoLog
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVideoLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVideoLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateAnimeEpisodeWithBodyWithResponse request with arbitrary body returning *CreateAnimeEpisodeResponse
func (c *ClientWithResponses) CreateAnimeEpisodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAnimeEpisodeResponse, error) {
	rsp, err := c.CreateAnimeEpisodeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAnimeEpisodeResponse(rsp)
}

func (c *ClientWithResponses) CreateAnimeEpisodeWithResponse(ctx context.Context, body CreateAnimeEpisodeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAnimeEpisodeResponse, error) {
	rsp, err := c.CreateAnimeEpisode(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAnimeEpisodeResponse(rsp)
}

// UpdateAnimeEpisodeWithBodyWithResponse request with arbitrary body returning *UpdateAnimeEpisodeResponse
func (c *ClientWithResponses) UpdateAnimeEpisodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAnimeEpisodeResponse, error) {
	rsp, err := c.UpdateAnimeEpisodeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAnimeEpisodeResponse(rsp)
}

func (c *ClientWithResponses) UpdateAnimeEpisodeWithResponse(ctx context.Context, body UpdateAnimeEpisodeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAnimeEpisodeResponse, error) {
	rsp, err := c.UpdateAnimeEpisode(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAnimeEpisodeResponse(rsp)
}

// DeleteAnimeEpisodeWithResponse request returning *DeleteAnimeEpisodeResponse
func (c *ClientWithResponses) DeleteAnimeEpisodeWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteAnimeEpisodeResponse, error) {
	rsp, err := c.DeleteAnimeEpisode(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAnimeEpisodeResponse(rsp)
}

// GetAnimeEpisodeListWithResponse request returning *GetAnimeEpisodeListResponse
func (c *ClientWithResponses) GetAnimeEpisodeListWithResponse(ctx context.Context, seasonId int, reqEditors ...RequestEditorFn) (*GetAnimeEpisodeListResponse, error) {
	rsp, err := c.GetAnimeEpisodeList(ctx, seasonId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeEpisodeListResponse(rsp)
}

// CreateAnimeSeasonWithBodyWithResponse request with arbitrary body returning *CreateAnimeSeasonResponse
func (c *ClientWithResponses) CreateAnimeSeasonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAnimeSeasonResponse, error) {
	rsp, err := c.CreateAnimeSeasonWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAnimeSeasonResponse(rsp)
}

func (c *ClientWithResponses) CreateAnimeSeasonWithResponse(ctx context.Context, body CreateAnimeSeasonJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAnimeSeasonResponse, error) {
	rsp, err := c.CreateAnimeSeason(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAnimeSeasonResponse(rsp)
}

// UpdateAnimeSeasonWithBodyWithResponse request with arbitrary body returning *UpdateAnimeSeasonResponse
func (c *ClientWithResponses) UpdateAnimeSeasonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAnimeSeasonResponse, error) {
	rsp, err := c.UpdateAnimeSeasonWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAnimeSeasonResponse(rsp)
}

func (c *ClientWithResponses) UpdateAnimeSeasonWithResponse(ctx context.Context, body UpdateAnimeSeasonJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAnimeSeasonResponse, error) {
	rsp, err := c.UpdateAnimeSeason(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAnimeSeasonResponse(rsp)
}

// DeleteAnimeSeasonWithResponse request returning *DeleteAnimeSeasonResponse
func (c *ClientWithResponses) DeleteAnimeSeasonWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteAnimeSeasonResponse, error) {
	rsp, err := c.DeleteAnimeSeason(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAnimeSeasonResponse(rsp)
}

// GetAnimeSeasonListWithResponse request returning *GetAnimeSeasonListResponse
func (c *ClientWithResponses) GetAnimeSeasonListWithResponse(ctx context.Context, seriesId int, reqEditors ...RequestEditorFn) (*GetAnimeSeasonListResponse, error) {
	rsp, err := c.GetAnimeSeasonList(ctx, seriesId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeSeasonListResponse(rsp)
}

// CreateSeriesWithBodyWithResponse request with arbitrary body returning *CreateSeriesResponse
func (c *ClientWithResponses) CreateSeriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSeriesResponse, error) {
	rsp, err := c.CreateSeriesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSeriesResponse(rsp)
}

func (c *ClientWithResponses) CreateSeriesWithResponse(ctx context.Context, body CreateSeriesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSeriesResponse, error) {
	rsp, err := c.CreateSeries(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSeriesResponse(rsp)
}

// UpdateSeriesWithBodyWithResponse request with arbitrary body returning *UpdateSeriesResponse
func (c *ClientWithResponses) UpdateSeriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSeriesResponse, error) {
	rsp, err := c.UpdateSeriesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSeriesResponse(rsp)
}

func (c *ClientWithResponses) UpdateSeriesWithResponse(ctx context.Context, body UpdateSeriesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSeriesResponse, error) {
	rsp, err := c.UpdateSeries(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSeriesResponse(rsp)
}

// DeleteSeriesWithResponse request returning *DeleteSeriesResponse
func (c *ClientWithResponses) DeleteSeriesWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteSeriesResponse, error) {
	rsp, err := c.DeleteSeries(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSeriesResponse(rsp)
}

// GetSeriesListWithResponse request returning *GetSeriesListResponse
func (c *ClientWithResponses) GetSeriesListWithResponse(ctx context.Context, params *GetSeriesListParams, reqEditors ...RequestEditorFn) (*GetSeriesListResponse, error) {
	rsp, err := c.GetSeriesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesListResponse(rsp)
}

// CreateTagWithBodyWithResponse request with arbitrary body returning *CreateTagResponse
func (c *ClientWithResponses) CreateTagWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagResponse, error) {
	rsp, err := c.CreateTagWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagResponse(rsp)
}

func (c *ClientWithResponses) CreateTagWithResponse(ctx context.Context, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagResponse, error) {
	rsp, err := c.CreateTag(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagResponse(rsp)
}

// UpdateTagWithBodyWithResponse request with arbitrary body returning *UpdateTagResponse
func (c *ClientWithResponses) UpdateTagWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error) {
	rsp, err := c.UpdateTagWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTagResponse(rsp)
}

func (c *ClientWithResponses) UpdateTagWithResponse(ctx context.Context, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error) {
	rsp, err := c.UpdateTag(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTagResponse(rsp)
}

// DeleteTagWithResponse request returning *DeleteTagResponse
func (c *ClientWithResponses) DeleteTagWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error) {
	rsp, err := c.DeleteTag(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagResponse(rsp)
}

// GetTagListWithResponse request returning *GetTagListResponse
func (c *ClientWithResponses) GetTagListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTagListResponse, error) {
	rsp, err := c.GetTagList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagListResponse(rsp)
}

// CreateVideoWithBodyWithResponse request with arbitrary body returning *CreateVideoResponse
func (c *ClientWithResponses) CreateVideoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVideoResponse, error) {
	rsp, err := c.CreateVideoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVideoResponse(rsp)
}

func (c *ClientWithResponses) CreateVideoWithResponse(ctx context.Context, body CreateVideoJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVideoResponse, error) {
	rsp, err := c.CreateVideo(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVideoResponse(rsp)
}

// UpdateVideoWithBodyWithResponse request with arbitrary body returning *UpdateVideoResponse
func (c *ClientWithResponses) UpdateVideoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVideoResponse, error) {
	rsp, err := c.UpdateVideoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVideoResponse(rsp)
}

func (c *ClientWithResponses) UpdateVideoWithResponse(ctx context.Context, body UpdateVideoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVideoResponse, error) {
	rsp, err := c.UpdateVideo(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVideoResponse(rsp)
}

// DeleteVideoWithResponse request returning *DeleteVideoResponse
func (c *ClientWithResponses) DeleteVideoWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteVideoResponse, error) {
	rsp, err := c.DeleteVideo(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVideoResponse(rsp)
}

// GetVideoWithResponse request returning *GetVideoResponse
func (c *ClientWithResponses) GetVideoWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetVideoResponse, error) {
	rsp, err := c.GetVideo(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVideoResponse(rsp)
}

// CreateVideoLogWithBodyWithResponse request with arbitrary body returning *CreateVideoLogResponse
func (c *ClientWithResponses) CreateVideoLogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVideoLogResponse, error) {
	rsp, err := c.CreateVideoLogWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVideoLogResponse(rsp)
}

func (c *ClientWithResponses) CreateVideoLogWithResponse(ctx context.Context, body CreateVideoLogJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVideoLogResponse, error) {
	rsp, err := c.CreateVideoLog(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVideoLogResponse(rsp)
}

// GetVideoLogWithResponse request returning *GetVideoLogResponse
func (c *ClientWithResponses) GetVideoLogWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetVideoLogResponse, error) {
	rsp, err := c.GetVideoLog(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVideoLogResponse(rsp)
}

// ParseCreateAnimeEpisodeResponse parses an HTTP response from a CreateAnimeEpisodeWithResponse call
func ParseCreateAnimeEpisodeResponse(rsp *http.Response) (*CreateAnimeEpisodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAnimeEpisodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AnimeEpisode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateAnimeEpisodeResponse parses an HTTP response from a UpdateAnimeEpisodeWithResponse call
func ParseUpdateAnimeEpisodeResponse(rsp *http.Response) (*UpdateAnimeEpisodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAnimeEpisodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnimeEpisode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAnimeEpisodeResponse parses an HTTP response from a DeleteAnimeEpisodeWithResponse call
func ParseDeleteAnimeEpisodeResponse(rsp *http.Response) (*DeleteAnimeEpisodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAnimeEpisodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAnimeEpisodeListResponse parses an HTTP response from a GetAnimeEpisodeListWithResponse call
func ParseGetAnimeEpisodeListResponse(rsp *http.Response) (*GetAnimeEpisodeListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeEpisodeListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AnimeEpisode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAnimeSeasonResponse parses an HTTP response from a CreateAnimeSeasonWithResponse call
func ParseCreateAnimeSeasonResponse(rsp *http.Response) (*CreateAnimeSeasonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAnimeSeasonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AnimeSeason
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateAnimeSeasonResponse parses an HTTP response from a UpdateAnimeSeasonWithResponse call
func ParseUpdateAnimeSeasonResponse(rsp *http.Response) (*UpdateAnimeSeasonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAnimeSeasonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnimeSeason
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAnimeSeasonResponse parses an HTTP response from a DeleteAnimeSeasonWithResponse call
func ParseDeleteAnimeSeasonResponse(rsp *http.Response) (*DeleteAnimeSeasonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAnimeSeasonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAnimeSeasonListResponse parses an HTTP response from a GetAnimeSeasonListWithResponse call
func ParseGetAnimeSeasonListResponse(rsp *http.Response) (*GetAnimeSeasonListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeSeasonListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AnimeSeason
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSeriesResponse parses an HTTP response from a CreateSeriesWithResponse call
func ParseCreateSeriesResponse(rsp *http.Response) (*CreateSeriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSeriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Series
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateSeriesResponse parses an HTTP response from a UpdateSeriesWithResponse call
func ParseUpdateSeriesResponse(rsp *http.Response) (*UpdateSeriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSeriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Series
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSeriesResponse parses an HTTP response from a DeleteSeriesWithResponse call
func ParseDeleteSeriesResponse(rsp *http.Response) (*DeleteSeriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSeriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSeriesListResponse parses an HTTP response from a GetSeriesListWithResponse call
func ParseGetSeriesListResponse(rsp *http.Response) (*GetSeriesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Series
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTagResponse parses an HTTP response from a CreateTagWithResponse call
func ParseCreateTagResponse(rsp *http.Response) (*CreateTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Tag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateTagResponse parses an HTTP response from a UpdateTagWithResponse call
func ParseUpdateTagResponse(rsp *http.Response) (*UpdateTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTagResponse parses an HTTP response from a DeleteTagWithResponse call
func ParseDeleteTagResponse(rsp *http.Response) (*DeleteTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTagListResponse parses an HTTP response from a GetTagListWithResponse call
func ParseGetTagListResponse(rsp *http.Response) (*GetTagListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Tag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateVideoResponse parses an HTTP response from a CreateVideoWithResponse call
func ParseCreateVideoResponse(rsp *http.Response) (*CreateVideoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVideoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Video
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateVideoResponse parses an HTTP response from a UpdateVideoWithResponse call
func ParseUpdateVideoResponse(rsp *http.Response) (*UpdateVideoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVideoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Video
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteVideoResponse parses an HTTP response from a DeleteVideoWithResponse call
func ParseDeleteVideoResponse(rsp *http.Response) (*DeleteVideoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVideoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVideoResponse parses an HTTP response from a GetVideoWithResponse call
func ParseGetVideoResponse(rsp *http.Response) (*GetVideoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVideoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Video
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateVideoLogResponse parses an HTTP response from a CreateVideoLogWithResponse call
func ParseCreateVideoLogResponse(rsp *http.Response) (*CreateVideoLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVideoLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VideoLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVideoLogResponse parses an HTTP response from a GetVideoLogWithResponse call
func ParseGetVideoLogResponse(rsp *http.Response) (*GetVideoLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVideoLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Create anime episode
	// (POST /anime/episode)
	CreateAnimeEpisode(ctx echo.Context) error
	// Update anime episode
	// (PUT /anime/episode)
	UpdateAnimeEpisode(ctx echo.Context) error
	// Delete anime episode
	// (DELETE /anime/episode/{id})
	DeleteAnimeEpisode(ctx echo.Context, id int) error
	// Get anime episode list
	// (GET /anime/episode_list/{season_id})
	GetAnimeEpisodeList(ctx echo.Context, seasonId int) error
	// Create anime season
	// (POST /anime/season)
	CreateAnimeSeason(ctx echo.Context) error
	// Update anime season
	// (PUT /anime/season)
	UpdateAnimeSeason(ctx echo.Context) error
	// Delete anime season
	// (DELETE /anime/season/{id})
	DeleteAnimeSeason(ctx echo.Context, id int) error
	// Get anime season list
	// (GET /anime/season_list/{series_id})
	GetAnimeSeasonList(ctx echo.Context, seriesId int) error
	// Create series
	// (POST /series)
	CreateSeries(ctx echo.Context) error
	// Update series
	// (PUT /series)
	UpdateSeries(ctx echo.Context) error
	// Delete series
	// (DELETE /series/{id})
	DeleteSeries(ctx echo.Context, id int) error
	// Get series list
	// (GET /series_list)
	GetSeriesList(ctx echo.Context, params GetSeriesListParams) error
	// Create tag
	// (POST /tag)
	CreateTag(ctx echo.Context) error
	// Update tag
	// (PUT /tag)
	UpdateTag(ctx echo.Context) error
	// Delete tag
	// (DELETE /tag/{id})
	DeleteTag(ctx echo.Context, id int) error
	// Get tag list
	// (GET /tag_list)
	GetTagList(ctx echo.Context) error
	// Create video
	// (POST /video)
	CreateVideo(ctx echo.Context) error
	// Update video
	// (PUT /video)
	UpdateVideo(ctx echo.Context) error
	// Delete video
	// (DELETE /video/{id})
	DeleteVideo(ctx echo.Context, id int) error
	// Get video
	// (GET /video/{id})
	GetVideo(ctx echo.Context, id int) error
	// Create video log
	// (POST /video_log)
	CreateVideoLog(ctx echo.Context) error
	// Get video log
	// (GET /video_log/{id})
	GetVideoLog(ctx echo.Context, id int) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// CreateAnimeEpisode converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAnimeEpisode(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateAnimeEpisode(ctx)
	return err
}

// UpdateAnimeEpisode converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateAnimeEpisode(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateAnimeEpisode(ctx)
	return err
}

// DeleteAnimeEpisode converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAnimeEpisode(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAnimeEpisode(ctx, id)
	return err
}

// GetAnimeEpisodeList converts echo context to params.
func (w *ServerInterfaceWrapper) GetAnimeEpisodeList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "season_id" -------------
	var seasonId int

	err = runtime.BindStyledParameterWithLocation("simple", false, "season_id", runtime.ParamLocationPath, ctx.Param("season_id"), &seasonId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAnimeEpisodeList(ctx, seasonId)
	return err
}

// CreateAnimeSeason converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAnimeSeason(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateAnimeSeason(ctx)
	return err
}

// UpdateAnimeSeason converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateAnimeSeason(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateAnimeSeason(ctx)
	return err
}

// DeleteAnimeSeason converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAnimeSeason(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAnimeSeason(ctx, id)
	return err
}

// GetAnimeSeasonList converts echo context to params.
func (w *ServerInterfaceWrapper) GetAnimeSeasonList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "series_id" -------------
	var seriesId int

	err = runtime.BindStyledParameterWithLocation("simple", false, "series_id", runtime.ParamLocationPath, ctx.Param("series_id"), &seriesId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter series_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAnimeSeasonList(ctx, seriesId)
	return err
}

// CreateSeries converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSeries(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateSeries(ctx)
	return err
}

// UpdateSeries converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateSeries(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateSeries(ctx)
	return err
}

// DeleteSeries converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSeries(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSeries(ctx, id)
	return err
}

// GetSeriesList converts echo context to params.
func (w *ServerInterfaceWrapper) GetSeriesList(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSeriesListParams
	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSeriesList(ctx, params)
	return err
}

// CreateTag converts echo context to params.
func (w *ServerInterfaceWrapper) CreateTag(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateTag(ctx)
	return err
}

// UpdateTag converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateTag(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateTag(ctx)
	return err
}

// DeleteTag converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTag(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteTag(ctx, id)
	return err
}

// GetTagList converts echo context to params.
func (w *ServerInterfaceWrapper) GetTagList(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTagList(ctx)
	return err
}

// CreateVideo converts echo context to params.
func (w *ServerInterfaceWrapper) CreateVideo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateVideo(ctx)
	return err
}

// UpdateVideo converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateVideo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateVideo(ctx)
	return err
}

// DeleteVideo converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteVideo(ctx, id)
	return err
}

// GetVideo converts echo context to params.
func (w *ServerInterfaceWrapper) GetVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVideo(ctx, id)
	return err
}

// CreateVideoLog converts echo context to params.
func (w *ServerInterfaceWrapper) CreateVideoLog(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateVideoLog(ctx)
	return err
}

// GetVideoLog converts echo context to params.
func (w *ServerInterfaceWrapper) GetVideoLog(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVideoLog(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/anime/episode", wrapper.CreateAnimeEpisode)
	router.PUT(baseURL+"/anime/episode", wrapper.UpdateAnimeEpisode)
	router.DELETE(baseURL+"/anime/episode/:id", wrapper.DeleteAnimeEpisode)
	router.GET(baseURL+"/anime/episode_list/:season_id", wrapper.GetAnimeEpisodeList)
	router.POST(baseURL+"/anime/season", wrapper.CreateAnimeSeason)
	router.PUT(baseURL+"/anime/season", wrapper.UpdateAnimeSeason)
	router.DELETE(baseURL+"/anime/season/:id", wrapper.DeleteAnimeSeason)
	router.GET(baseURL+"/anime/season_list/:series_id", wrapper.GetAnimeSeasonList)
	router.POST(baseURL+"/series", wrapper.CreateSeries)
	router.PUT(baseURL+"/series", wrapper.UpdateSeries)
	router.DELETE(baseURL+"/series/:id", wrapper.DeleteSeries)
	router.GET(baseURL+"/series_list", wrapper.GetSeriesList)
	router.POST(baseURL+"/tag", wrapper.CreateTag)
	router.PUT(baseURL+"/tag", wrapper.UpdateTag)
	router.DELETE(baseURL+"/tag/:id", wrapper.DeleteTag)
	router.GET(baseURL+"/tag_list", wrapper.GetTagList)
	router.POST(baseURL+"/video", wrapper.CreateVideo)
	router.PUT(baseURL+"/video", wrapper.UpdateVideo)
	router.DELETE(baseURL+"/video/:id", wrapper.DeleteVideo)
	router.GET(baseURL+"/video/:id", wrapper.GetVideo)
	router.POST(baseURL+"/video_log", wrapper.CreateVideoLog)
	router.GET(baseURL+"/video_log/:id", wrapper.GetVideoLog)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+yay24kNRfHX6Xl71uA1Ep3GFa9m5mMhogIRpBhE0WRU3VS8UxXuWK7glpRSyQRN82C",
	"DYsBsQENYgESOxYo8DI9Fx4D+VLuurguIemeamU2Sbdd9jk+f5/zc1X1CfJoGNMIIsHR6ARx7xBCrD7e",
	"jkgI92LCqQ/ye8xoDEwQUL3El38FEWNAI2Qu621uoD4Sk1i2kUhAAAxN+yhKwn1grgGmxw7igpEokGM4",
	"YE6jvbydj1VjlRme7JsLy4Zsn8PUMfGBFix9ItvchqZ9xOAoIQx8NNqRkch6m5lu146l+4/AE9KWiqpe",
	"RjmoHuZC/veBe4zEgsiL0Isv/3x58e0/n30ufTHuqSsdS/Fownh5itnZ77Pzi9n5r2+9+uXJ7Oyn2fmT",
	"2fmP/Rdf/Db/8vLpz5meZ9/YL29n7ar5HYYvo1PMqJ942rXSYr/64/lfPzy/+P7Vs78zdjNDnHuFEeCl",
	"vSIbK/fKJKIxJ65YnZ7Nzr6enX43O32a8cAOcNgv7bqKrebeOanv6TyubbMBBzgZi3uMUfYR8JhG3JGU",
	"IXCOg/z+lyN6aYfLo5ItHbimlK8Pr8CBHiMgVB/+z+AAjdD/BvN6MzDFZrCNs1HUY+2kmDE8uWqQqwMr",
	"bTesdBsHlYUNh1C8VLW18kpd6XJKFZ+yW/uMYl9m/p4gebt30p6e6nG52rq89VE8xpN97D0umXlgOqqs",
	"lBdZubot2hh37eOYBtfuZx8lHFihXjzkwKosXQMh7BRz48UVlIMlZyLRAc3afQ97hyQkIundfrApJwbG",
	"deUarq2vrUt3aQwRjgkaoVtrw7Vb0hAWhyrEAywBNIAM16mGjhQCyxq46aMRussAC8idAfSigIs71J8o",
	"XNFIQKQG4zgeE08NHzwybNPp3ZT8ORPTfOgES0A16IKnFvDOcH2BtvMo0EHwkepQBfjaTDsLusMFdYHa",
	"UTwJQ8wm1q2eUrIHVh1dc3f0EcO278pESRwKP4z9rio8XJrCH77fNXG1LK3FnfYLKT04If5Un2rGIKCs",
	"+4ZqL+geY4ZDECAPjzvFE1HudE9kiywnKcBGur7lNe1nIlWqjrslwd8tH8M+oL27RouOKaQD+N8V2hsT",
	"LgYn9pZBqRWAI0Xvg8jqtEXUob9Wq+zJ2yFV9j7lSopdLkVbHQPzuVo8AK5C7t4Hkd8WvbGWrHlv8Pkt",
	"YROPzd3jAou1sfA6aJw1vXow5qk0ecFNcxsUd0vc4bLE7TiHm3Qt5vFlIGwVv0pdv8kIvqw4lr/mwUsz",
	"f3Xw2+F3/lTEid/5w55O4jfN0NWmr9bZDd/ctuDzR1011DUPxBZTk83kS2Zt1uoqYZanUqSimoU0oLUz",
	"Cg6XoGBnWVot3jwXW5LTCnqVanwzodlGBYXIOizqMS1vSJl32HsMk08p81MhjhJgk7kSR8gRePvofCn4",
	"S/NpVcmnhSsyL6etMO86alC3jYMFVUn1kme5kLMmV4lwQimQ6ieX0MC2Dkg2XLRknUWaSy2Tai1JpuWr",
	"LaH2BeQbhhmG1YS9EV3bODDcWjxU0jfbK0kUgYMiTuaRPravqGtoot9jL6Y46bmXTJSM0VViyrHRIZVR",
	"L6OBKx0Rb7h48TpLlyrdbAK2ZEwqZS1lMr9neMMZw5nqxKmiSydCfSNzRiKrMWH2xjRoRa0tGiyy9snp",
	"Xwe7rN2Vw1dvTIOisj25nIK6tiTWZqiWt0WS2p+frUKiVqjb4VytU3U6/TcAAP//dmSoi54uAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
